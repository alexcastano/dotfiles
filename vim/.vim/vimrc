call plug#begin('~/.vim/plugged')

Plug 'AndrewRadev/splitjoin.vim'
Plug 'SirVer/ultisnips'
Plug 'airblade/vim-gitgutter'
Plug 'altercation/vim-colors-solarized'
Plug 'benmills/vimux'
Plug 'chrisbra/csv.vim'
Plug 'christoomey/vim-tmux-navigator'
Plug 'danro/rename.vim'
Plug 'godlygeek/tabular'
Plug 'janko-m/vim-test'
Plug 'junegunn/fzf.vim'
Plug 'kana/vim-textobj-entire'
Plug 'kana/vim-textobj-user'
Plug 'kchmck/vim-coffee-script'
Plug 'majutsushi/tagbar'
Plug 'mileszs/ack.vim'
Plug 'moll/vim-bbye'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'nelstrom/vim-textobj-rubyblock'
Plug 'nelstrom/vim-visual-star-search'
Plug 'neomake/neomake'
Plug 'nicwest/QQ.vim'
Plug 'pbrisbin/vim-mkdir'
Plug 'plasticboy/vim-markdown'
Plug 'powerman/vim-plugin-AnsiEsc'
Plug 'sheerun/vim-polyglot'
Plug 'szw/vim-maximizer'
Plug 'tmux-plugins/vim-tmux'
Plug 'tommcdo/vim-exchange'
Plug 'tpope/vim-abolish'
Plug 'tpope/vim-bundler'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-dispatch'
" Plug 'tpope/vim-endwise'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-obsession'
Plug 'tpope/vim-rails'
Plug 'tpope/vim-rake'
Plug 'tpope/vim-rbenv'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-rsi'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'wesQ3/vim-windowswap'

if has('nvim')
  Plug 'autozimu/LanguageClient-neovim', {
        \ 'branch': 'next',
        \ 'do': 'bash install.sh',
        \ }

  Plug 'ncm2/ncm2'
  Plug 'roxma/nvim-yarp'
  " enable ncm2 for all buffers
  autocmd BufEnter * call ncm2#enable_for_buffer()

  " IMPORTANTE: :help Ncm2PopupOpen for more information
  set completeopt=noinsert,menuone,noselect
  inoremap <silent> <expr> <CR> (pumvisible() ? "\<c-y>\<cr>" : "\<CR>")

  Plug 'ncm2/ncm2-bufword'  " ncm2 plugin for completing words present in current buffer
  Plug 'ncm2/ncm2-path'     " ncm2 plugin for completing file paths
  Plug 'ncm2/ncm2-tmux'     " ncm2 plugin for completing words present in tmux buffers

  " suppress the annoying 'match x of y', 'The only match' and 'Pattern not found' messages
  set shortmess+=c

  " CTRL-C doesn't trigger the InsertLeave autocmd . map to <ESC> instead.
  inoremap <c-c> <ESC>

  " When the <Enter> key is pressed while the popup menu is visible, it only
  " hides the menu. Use this mapping to close the menu and also start a new
  " line.
  " let g:endwise_no_mappings = 1
  " imap <C-X><CR>   <CR><Plug>AlwaysEnd


  Plug 'Shougo/echodoc.vim'

  let g:LanguageClient_serverCommands = {
        \ 'elixir': ['/home/alex/bin/elixirls'],
        \ }
  let g:LanguageClient_autoStart = 1
  let g:LanguageClient_diagnosticsEnable = 1
  let g:LanguageClient_diagnosticsList = "location"

  " call LanguageClient#setLoggingLevel('DEBUG')
endif

if has('nvim')
  Plug 'iCyMind/NeoSolarized'
else
  Plug 'altercation/vim-colors-solarized'
endif
call plug#end()

if has('nvim')
  colorscheme NeoSolarized
  set termguicolors
else
  let g:solarized_termcolors=16
  let g:solarized_termtrans = 1
  colorscheme solarized
end

set t_Co=16
set background=light

autocmd BufReadPost *.ex setlocal filetype=elixir
autocmd BufReadPost *.exs setlocal filetype=elixir

" Use Vim settings, rather than Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
set nocompatible

" allow backspacing over everything in insert mode
set history=500    " keep 50 lines of command line history

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
  set guifont=Monospace\ 9
endif

" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  runtime macros/matchit.vim

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
    au!

    " For all text files set 'textwidth' to 78 characters.
    autocmd FileType text setlocal textwidth=78

    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " Also don't do it when the mark is in the first line, that is the default
    " position when opening a file.
    autocmd BufReadPost *
          \ if line("'\"") > 0 && line("'\"") <= line("$") |
          \   exe "normal! g`\"" |
          \ endif

    autocmd FileType text,markdown,html setlocal wrap linebreak nolist number
    au BufRead,BufNewFile *.md set filetype=markdown


    " autocmd BufNewFile,BufReadPost *.coffee setl foldmethod=indent

  augroup END

else

  set autoindent    " always set autoindenting on

endif " has("autocmd")

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
        \ | wincmd p | diffthis
endif


" Tabs
set ts=2  " Tabs are 2 spaces
set shiftwidth=2  " Tabs under smart indent
set smarttab
set expandtab
set cursorline

set backspace=indent,eol,start " Backspace over everything in insert mode
set showcmd   " Show (partial) command in status line.
set ignorecase    " Do case insensitive matching
set smartcase   " Do smart case matching
set incsearch   " Incremental search
set hls             " Highlight
set autowrite   " Automatically save before commands like :next and :make
set hidden             " Hide buffers when they are abandoned

set cf  " Enable error files & error jumping.
set autowrite  " Writes on make/shell commands
set ruler  " Ruler on
set nowrap  " Line wrapping off
set timeoutlen=1000  " Time to wait after ESC (default causes an annoying delay)
set ttimeoutlen=-1
set laststatus=2  " Always show status line.

" Fold
" set foldmethod=indent

set relativenumber
set number

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a   " Enable mouse usage (all modes) in terminals
  set mousehide     " Hide mouse after chars typed
endif

" No blinking  No noise
set noerrorbells visualbell t_vb=
autocmd GUIEnter * set visualbell t_vb=

" " Formatting (some of these are for coding in C and C++)
set nocp incsearch
set cinoptions=:0,p0,t0
set cinwords=if,else,while,do,for,switch,case
set formatoptions=tcqr
abbr #i #include
abbr #d #define

" Completion commands with tab
set wildmode=longest,list,full
set wildmenu


" Save as sudo
command! WW w !sudo tee % >/dev/null

" OpenURL command for rails plugin
":command -bar -nargs=1 OpenURL :!chromium <args>

" Rails default file
let g:rails_default_file='config/database.yml'

"
" Visual
set showmatch  " Show matching brackets.
set mat=5  " Bracket blinking.

" Backups
if has("vms")
  set nobackup " do not keep a backup file, use versions instead
else
  set backup   " keep a backup file
endif

set backupdir=~/.vim_backups " Where backups will go.

set directory=~/.vim_tmp     " Where temporary files will go.

" leader key is space
nnoremap <Space> <Nop>
let mapleader = "\<Space>"

" Reload vim after save this file
" autocmd BufWritePost vimrc source %

" Faster command mode
nnoremap ; :
nnoremap : ;
vnoremap ; :
vnoremap : ;

" sessions
map <leader>ss ;mksession! ~/.vim_tmp/last_session<cr>
map <leader>sl ;source ~/.vim_tmp/last_session<cr>

" This is to set the current directory
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
map <leader>ew ;e %%
map <leader>es ;sp %%
map <leader>ev ;vsp %%
map <leader>et ;tabe %%

map <leader>d "_d

" Each time you press S, the yanked text is _stamped_ over the current word.
nnoremap S diw"0P
vnoremap S "_d"0P

" better movement in spplit lines
noremap  <buffer> <silent> k gk
noremap  <buffer> <silent> j gj
" noremap  <buffer> <silent> 0 g0
" noremap  <buffer> <silent> $ g$

" Faster windows movement
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap <C-h> <C-w>h

" highligth extre spaces
highlight ExtraWhitespace ctermbg=darkgreen guibg=darkgreen
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Yank until the end of the line
map Y y$

" disabling Q
map Q <Nop>

" Vimux
" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <leader>r "vy ;call VimuxSendText(@v)<CR>']
" VimuxSendKeys("'" . escape(@k, "'") . "'")

" Select current paragraph and send it to tmux
nmap <leader>rr vip<leader>r

" Run the nearest test with rspec
autocmd FileType ruby nmap <leader>rT ;call VimuxRunCommand("bin/rspec " . bufname("%"))<CR>

" Run the current file with rspec
autocmd FileType ruby nmap <leader>rt ;call VimuxRunCommand("bin/rspec " . bufname("%") . ":" . line('.'))<CR>

" Run all the tests with rspec
autocmd FileType ruby nmap <leader>ra ;call VimuxRunCommand("bin/rspec")<CR>

" Run the nearest test with minitest
autocmd FileType ruby nmap <leader>rM ;call VimuxRunCommand("m " . bufname("%"))<CR>

" Run the current file with rspec
autocmd FileType ruby nmap <leader>rm ;call VimuxRunCommand("m " . bufname("%") . ":" . line('.'))<CR>

autocmd FileType elixir nmap <leader>rT ;call VimuxRunCommand("mix test " . bufname("%"))<CR>
autocmd FileType elixir nmap <leader>rt ;call VimuxRunCommand("mix test " . bufname("%") . ":" . line('.'))<CR>
autocmd FileType elixir nmap <leader>ra ;call VimuxRunCommand("mix test")<CR>
autocmd FileType elixir nmap <leader>rs ;call VimuxRunCommand("iex -S mix")<CR>
autocmd FileType elixir nmap <leader>rb ;call VimuxRunCommand("mix compile")<CR>

autocmd FileType elixir nnoremap <silent> K :call LanguageClient#textDocument_hover()<CR>
autocmd FileType elixir nnoremap <silent> <F2> :call LanguageClient#textDocument_references()<CR>
autocmd FileType elixir nnoremap <silent> <F3> :call LanguageClient#textDocument_formatting()<CR>
autocmd FileType elixir nnoremap <silent> g] :call LanguageClient#textDocument_definition()<CR>
autocmd FileType elixir nnoremap <silent> <C-]> :call LanguageClient#textDocument_definition()<CR>
autocmd FileType elixir set formatexpr=LanguageClient#textDocument_rangeFormatting()

" autocmd! FileType qf nnoremap <buffer> <leader><Enter> <C-w><Enter><C-w>L

" Prompt for a command to run
nmap <leader>rc ;VimuxPromptCommand<CR>

" Run last command executed by VimuxRunCommand
nmap <leader>r. ;VimuxRunLastCommand<CR>

" Inspect runner pane
nmap <leader>ri ;VimuxInspectRunner<CR>

" Close vim tmux runner opened by VimuxRunCommand
nmap <leader>rq ;VimuxCloseRunner<CR>

" Interrupt any command running in the runner pane
nmap <leader>rx ;VimuxInterruptRunner<CR>

" Zoom the runner pane (use <bind-key> z to restore runner pane)
nmap <leader>rz ;call VimuxZoomRunner()<CR>

" Send exit to the pane
nmap <leader>re ;call VimuxSendKeys("C-d")<CR>

" Previous command using Control-p Enter
nmap <leader>rp ;call VimuxSendKeys("C-p Enter")<CR>

" Pretty json
nmap <leader>pj vip<leader>pj
vmap <leader>pj ;!python -m json.tool<CR>

" Pretty xml
function! DoPrettyXML()
  " save the filetype so we can restore it later
  let l:origft = &ft
  set ft=
  " delete the xml header if it exists. This will
  " permit us to surround the document with fake tags
  " without creating invalid xml.
  1s/<?xml .*?>//e
  " insert fake tags around the entire document.
  " This will permit us to pretty-format excerpts of
  " XML that may contain multiple top-level elements.
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  " xmllint will insert an <?xml?> header. it's easy enough to delete
  " if you don't want it.
  " delete the fake tags
  2d
  $d
  " restore the 'normal' indentation, which is one extra level
  " too deep due to the extra tags we wrapped around the document.
  silent %<
  " back to home
  1
  " restore the filetype
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()

nmap <leader>px ;PrettyXML<CR>

" Vim Airline
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1

" Gitgutter
let g:gitgutter_realtime = 750
" let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0
highlight clear SignColumn

" Syntastic
" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list            = 0
" let g:syntastic_check_on_open            = 1
" let g:syntastic_check_on_wq              = 0


" Undo
set undofile                " Save undo's after file closes
set undodir=~/.vim_undo     " where to save undo histories
set undolevels=1000         " How many undos
set undoreload=10000        " number of lines to save for undo

" Align with tabular
nmap <leader>a= ;Tabularize /=<CR>
vmap <leader>a= ;Tabularize /=<CR>
nmap <leader>a: ;Tabularize /:\zs<CR>
vmap <leader>a: ;Tabularize /:\zs<CR>
nmap <leader>a# ;Tabularize /#<CR>
vmap <leader>a# ;Tabularize /#<CR>
nmap <leader>a\| ;Tabularize /\|<CR>
vmap <leader>a\| ;Tabularize /\|<CR>
nmap <leader>a" ;Tabularize /"<CR>
vmap <leader>a" ;Tabularize /"<CR>

vmap R "_dP // Replace the selected text with the clipboard without overwritting
set wildignore+=*/tmp/*,*/node_modules/*

noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

" resize horzontal split window
nmap <Left> <C-W><
nmap <Right> <C-W>>
" resize vertical split window
nmap <Up> <C-W>-
nmap <Down> <C-W>+

" Indent plugin
let g:indent_guides_enable_on_vim_startup = 1

" grep word under cursor
nnoremap <leader>gg :Ack! "\b<C-R><C-W>\b"<CR>
nnoremap <leader>gt :Ack! "TODO\\|FIXME"<CR>
nnoremap <leader>gs :Ack! "" \| cw<Left><Left><Left><Left><Left><Left>
vnoremap <leader>g "gy:Ack! "<C-R>g"<CR>

let g:maximizer_set_default_mapping = 0
nnoremap <leader>z :MaximizerToggle<CR>

ab riex require IEx; IEx.pry
ab rpry require 'pry'; binding.pry
ab rirb require 'irb'; binding.irb
ab lastest latest

autocmd BufRead,BufNewFile *.md setlocal spell
set complete+=kspell

" netrw
let g:netrw_banner = 0
let g:netrw_liststyle = 3
let g:netrw_browse_split = 4
let g:netrw_altv = 1
let g:netrw_winsize = 20
" augroup ProjectDrawer
"   autocmd!
"   autocmd VimEnter * :Vexplore
" augroup END

" Remove current file
command! RRm call delete(expand('%'))

" Remove current file and buffer
command! RRM call delete(expand('%')) | bdelete!


" let test#strategy = "neomake"
let test#strategy = "dispatch"

nmap <leader>tt ;TestNearest<CR>
nmap <leader>tf ;TestFile<CR>
nmap <leader>ta ;TestSuite<CR>
nmap <leader>t. ;TestLast<CR>
nmap <leader>tv ;TestVisit<CR>

" nmap <silent> <leader>tt :TestNearest<CR>
" nmap <silent> <leader>tf :TestFile<CR>
" nmap <silent> <leader>ta :TestSuite<CR>
" nmap <silent> <leader>t. :TestLast<CR>
" nmap <silent> <leader>tv :TestVisit<CR>
"
" This is the default extra key bindings
let g:fzf_action = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-x': 'split',
  \ 'ctrl-v': 'vsplit' }

" Default fzf layout
" - down / up / left / right
let g:fzf_layout = { 'up': '~40%' }

" In Neovim, you can set up fzf window using a Vim command
let g:fzf_layout = { 'window': 'enew' }
let g:fzf_layout = { 'window': '-tabnew' }
let g:fzf_layout = { 'window': '10split enew' }

" Customize fzf colors to match your color scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Enable per-command history.
" CTRL-N and CTRL-P will be automatically bound to next-history and
" previous-history instead of down and up. If you don't like the change,
" explicitly bind the keys to down and up in your $FZF_DEFAULT_OPTS.
let g:fzf_history_dir = '~/.local/share/fzf-history'
let $FZF_DEFAULT_COMMAND = 'ag -l --nocolor -g ""'
nmap <c-p> ;Files<cr>
